import os
import shutil
import re

'''
Organized submissions downloaded in bulk from canvas.

Students get organized based on which section they are in.
All of a student's submitted files will be placed inside of a folder with their name.
Each section of students will have its own folder with the student folders contained within.

The script will ask for a path to a directory that contains the submission folder.
This submission folder is simply the bulk .zip downloaded from canvas that has been extracted.
**The path needs to be to the folder that contains the unzipped submissions folder, not the submissions folder itself.**

The script will look for a series of ###.section files containing the student's names in the format from canvas.
Since the format of the names is specific to canvas, only use files generated by this script.
If you have a set of ###.section files, place them in the same directory that contains the submissions folder.
The script will look for the section files in the location you provide at the start.
This will shorten the setup process of organizing the students into their respective sections.
'''


class Student:
    sections = {
        # Add sections for class here
        '103': {},
        '104-A': {},
        '104-B': {},

        # Use to hold students until section is found
        None: {}
    }

    students = {}

    def __new__(cls, name, section=None):
        ''' Check to make sure student doesn't exist before creating a new Student '''
        if name in Student.students:
            return Student.students[name]
        else:
            student = super(Student, cls).__new__(cls)
            return student

    def __init__(self, name, section=None):
        if name in Student.students:
            # Do not initialize
            return

        self.name = name
        self.section = section
        self.submissions = []

        Student.sections[self.section][self.name] = self
        Student.students[self.name] = self

    def addSubmission(self, submission):
        self.submissions.append(submission)

    def setSection(self, section):
        Student.sections[section][self.name] = self
        del Student.sections[self.section][self.name]
        self.section = section

    def __eq__(self, value):
        if type(value) != type(self):
            raise NotImplementedError(f"Cannot compare {type(self)} with {type(value)}!")
        return self.name == value.name and self.section == value.section

    def __hash__(self):
        return hash(self.name)

    def __str__(self):
        return f'{self.name}'

    def __repr__(self):
        return f'{self.name}: {self.section}'


class StudentSubmission:
    '''Represents a file submitted by a student

    Contains a number of methods to help with renaming, compiling, and executing
    '''

    canvasPattern = re.compile(r'(\w+)_(?:\w*?_)?\d+_\d+_([\w\d-]+.java)')
    duplicateNamePattern = re.compile(r'(\w+)-\d+.java')

    def __new__(cls, fileName, parentDirectory=None):
        matches = re.match(StudentSubmission.canvasPattern, fileName)
        if(matches):
            return object.__new__(cls)
        else:
            print(f"{fileName} not recognized by the pattern matcher!")
            return None

    def __init__(self, fileName, parentDirectory=None):
        matches = re.match(StudentSubmission.canvasPattern, fileName)
        if(matches):
            self.student = Student(matches.group(1))
            self.programName = matches.group(2)
            duplicateName = re.match(StudentSubmission.duplicateNamePattern, self.programName)
            if(duplicateName):
                self.programName = duplicateName.group(1) + '.java'

            self.execName = self.programName.split('.')[0]
        else:
            raise ValueError(f"{fileName} not recognized by the pattern matcher!")

        if parentDirectory is None:
            self.parentDirectory = os.getcwd()
        else:
            self.parentDirectory = parentDirectory

        self.fileName = fileName

    def rename(self, newName):
        ''' Renames the file associated with this submission '''
        os.rename(f'{self.parentDirectory}/{self.fileName}',
                  f'{self.parentDirectory}/{newName}')

        self.fileName = newName

    def move(self, newDirectory):
        ''' Copies the file associated with this submission to a new directory'''
        shutil.copy(f'{self.parentDirectory}/{self.fileName}',
                    f'{newDirectory}/{self.fileName}')

        self.parentDirectory = newDirectory

    def __repr__(self):
        return f'StudentSubmission("{self.fileName}")'

    def __str__(self):
        return f'{self.fileName}'

workingDirectory = input("Enter the path to the directory that contains the submissions folder: ")
outputDirectory = f'{workingDirectory}/submissionSetup'
submissionDirectory = f'{workingDirectory}/submissions'

if(not(os.path.exists(outputDirectory))):
            os.mkdir(outputDirectory)

os.chdir(workingDirectory)

files = os.listdir(submissionDirectory)

# Create StudentSubmissions
studentFiles = (StudentSubmission(file, submissionDirectory) for file in files)

submissions = []
for submission in studentFiles:
    if submission is None:
        continue
    submissions.append(submission)

# Read in students from files
for section in Student.sections:
    fileName = f'{workingDirectory}/{section}.section'
    if os.path.exists(fileName) and os.path.isfile(fileName):
        with open(fileName, 'r') as sectionFile:
            for name in sectionFile:
                if len(name) < 2:
                    print(f'{name} too short!')
                    continue
                student = Student(name.strip())
                student.setSection(section)

# Organize students by section by hand
for section in Student.sections:
    if len(Student.sections[None]) == 0:
        break

    if section is None:
        for name in list(Student.sections[None]):
            student = Student(name)
            found = False
            while not found:
                s = input(f'Enter the section that {name} is in: ').strip()
                try:
                    student.setSection(s)
                except KeyError:
                    print(f'{s} is not a valid section number!')
                    print('Your options are: ')
                    print(*list(Student.sections.keys())[:-1], sep=', ')
                else:
                    found = True
        continue

    sectionList = Student.sections[section]

    print(f"Currently listed in section {section}")
    print(*sectionList, sep='\n')

    name = ''
    while not name.startswith('-'):
        name = input(
            f"Enter the start of last name for a student in section {section} to search for or '-' to stop: "
            ).lower()

        if name.startswith('-'):
            continue

        hits = []
        for studentName in Student.sections[None]:
            if studentName.startswith(name):
                hits.append(studentName)

        if not hits:
            print("No submission found!")
            continue

        for hit in hits:
            inSection = 'y' in input(f'Is {hit} in section {section}?')
            if inSection:
                student = Student(hit)
                student.setSection(section)

    print(f"Currently listed in section {section}")
    print(*sectionList, sep='\n')

# Write text file for each section containing student's names
for section in Student.sections:
    fileName = f'{outputDirectory}/{section}.section'

    with open(fileName, 'w') as sectionFile:
        for student in Student.sections[section]:
            print(student, file=sectionFile)

# Organize each submission into student folders by section
for submission in submissions:
    section = submission.student.section
    name = submission.student.name
    destination = f'{outputDirectory}/{section}/{name}'

    if(not(os.path.exists(destination))):
            os.makedirs(destination)

    submission.move(destination)
    submission.rename(submission.programName)
